<!doctype html><html lang=en-us><head><title>OSTEP 读书笔记: 并发之锁 // RojerAlone</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="RojerAlone"><meta name=description content><link rel=stylesheet href=https://rojeralone.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','G-T1VNZF1VBZ','auto'),ga('send','pageview'))</script><meta name=twitter:card content="summary"><meta name=twitter:title content="OSTEP 读书笔记: 并发之锁"><meta name=twitter:description content="评估 如果评估锁的好坏？
 是否能够做到互斥 公平性，避免饥饿 性能  实现方式 控制中断 最简单的实现方式，当执行需要互斥的代码时，禁止中断。
问题：
 禁止中断是特权操作，普通进程能执行这个操作比较危险 多处理器时，这种方式就不管用了 关掉中断可能导致比较重要的中断无法响应，甚至导致系统崩溃 性能很差  Loads / Stores 用一个变量标识是否获取了锁，问题是，两个线程同时执行 if (flag == 0) flag = 1 这个操作，这不是个原子操作，可能会被中断，A 准备赋值为 1 时被中断了，导致另一个线程认为自己应该获取锁，那么两个线程都能获取到锁。
Test-And-Set 自旋锁 硬件提供了 Test-And-Set 指令，对某个变量设置新值的同时返回旧值，操作系统在这个指令的基础上实现锁的概念。
这个实现方式可以保证互斥，但是不能保证公平，性能也比较差，存在浪费 CPU 的情况（一直循环执行 Test-And-Set）。
另外，一些 CPU 也提供了另一种硬件支持的原语，Compare-And-Set CAS，也能实现锁。
还有其他的硬件支持的指令，比如 Fetch-And-Add
Just Yield 在自旋锁的基础上优化性能，对于没获取到锁的线程，让出自己的 CPU，然后等待已经获取锁的线程使用完后释放锁，主动唤醒正在等待的线程。
问题是，并不能解决饥饿问题，存在线程反复获取锁然后释放，导致另一些线程一直等待的问题。
等待队列 解决上一种实现方式的问题，没获取到锁的线程排队进入一个队列里，获取了锁的线程释放锁时，唤醒队列中第一个线程，避免无尽等待。需要操作系统提供支持，park() 用来让出 CPU 并睡眠，unpark(pid) 用来唤醒指定线程。
两阶段锁 进一步优化，第一阶段尝试自旋获取锁，如果在执行时间内没有获取到锁，再进入等待队列。
锁相关的数据结构 并发计数器 多个线程同时执行加法计算，由于要保证并发安全，需要加锁，那么多线程执行时的速度就很慢。理论上，多线程应该要比单线程要快，实际可能并非如此。
通过多核 CPU 同时执行，能够提升相应的性能，叫做完美扩展，比如原来单个 CPU 需要 1s 完成的任务，任务量扩大了 3 倍，3 个 CPU 同时执行，还是只需要 1s 就能完成。"><meta property="og:title" content="OSTEP 读书笔记: 并发之锁"><meta property="og:description" content="评估 如果评估锁的好坏？
 是否能够做到互斥 公平性，避免饥饿 性能  实现方式 控制中断 最简单的实现方式，当执行需要互斥的代码时，禁止中断。
问题：
 禁止中断是特权操作，普通进程能执行这个操作比较危险 多处理器时，这种方式就不管用了 关掉中断可能导致比较重要的中断无法响应，甚至导致系统崩溃 性能很差  Loads / Stores 用一个变量标识是否获取了锁，问题是，两个线程同时执行 if (flag == 0) flag = 1 这个操作，这不是个原子操作，可能会被中断，A 准备赋值为 1 时被中断了，导致另一个线程认为自己应该获取锁，那么两个线程都能获取到锁。
Test-And-Set 自旋锁 硬件提供了 Test-And-Set 指令，对某个变量设置新值的同时返回旧值，操作系统在这个指令的基础上实现锁的概念。
这个实现方式可以保证互斥，但是不能保证公平，性能也比较差，存在浪费 CPU 的情况（一直循环执行 Test-And-Set）。
另外，一些 CPU 也提供了另一种硬件支持的原语，Compare-And-Set CAS，也能实现锁。
还有其他的硬件支持的指令，比如 Fetch-And-Add
Just Yield 在自旋锁的基础上优化性能，对于没获取到锁的线程，让出自己的 CPU，然后等待已经获取锁的线程使用完后释放锁，主动唤醒正在等待的线程。
问题是，并不能解决饥饿问题，存在线程反复获取锁然后释放，导致另一些线程一直等待的问题。
等待队列 解决上一种实现方式的问题，没获取到锁的线程排队进入一个队列里，获取了锁的线程释放锁时，唤醒队列中第一个线程，避免无尽等待。需要操作系统提供支持，park() 用来让出 CPU 并睡眠，unpark(pid) 用来唤醒指定线程。
两阶段锁 进一步优化，第一阶段尝试自旋获取锁，如果在执行时间内没有获取到锁，再进入等待队列。
锁相关的数据结构 并发计数器 多个线程同时执行加法计算，由于要保证并发安全，需要加锁，那么多线程执行时的速度就很慢。理论上，多线程应该要比单线程要快，实际可能并非如此。
通过多核 CPU 同时执行，能够提升相应的性能，叫做完美扩展，比如原来单个 CPU 需要 1s 完成的任务，任务量扩大了 3 倍，3 个 CPU 同时执行，还是只需要 1s 就能完成。"><meta property="og:type" content="article"><meta property="og:url" content="https://rojeralone.github.io/ostep/concurrency-lock/"><meta property="article:section" content="ostep"><meta property="article:published_time" content="2021-07-19T23:27:08+08:00"><meta property="article:modified_time" content="2021-07-19T23:27:08+08:00"></head><body><header class=app-header><a href=https://rojeralone.github.io/><img class=app-header-avatar src=/avatar.jpg alt=RojerAlone></a><h1>RojerAlone</h1><p>Developer</p><div class=app-header-social><a href=https://github.com/RojerAlone target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>OSTEP 读书笔记: 并发之锁</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 19, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://rojeralone.github.io/tags/ostep/>ostep</a>
<a class=tag href=https://rojeralone.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div></div></header><div class=post-content><h2 id=评估>评估</h2><p>如果评估锁的好坏？</p><ol><li>是否能够做到互斥</li><li>公平性，避免饥饿</li><li>性能</li></ol><h2 id=实现方式>实现方式</h2><h3 id=控制中断>控制中断</h3><p>最简单的实现方式，当执行需要互斥的代码时，禁止中断。</p><p>问题：</p><ul><li>禁止中断是特权操作，普通进程能执行这个操作比较危险</li><li>多处理器时，这种方式就不管用了</li><li>关掉中断可能导致比较重要的中断无法响应，甚至导致系统崩溃</li><li>性能很差</li></ul><h3 id=loads--stores>Loads / Stores</h3><p>用一个变量标识是否获取了锁，问题是，两个线程同时执行 <code>if (flag == 0) flag = 1</code> 这个操作，这不是个原子操作，可能会被中断，A 准备赋值为 1 时被中断了，导致另一个线程认为自己应该获取锁，那么两个线程都能获取到锁。</p><h3 id=test-and-set-自旋锁>Test-And-Set 自旋锁</h3><p>硬件提供了 <code>Test-And-Set</code> 指令，对某个变量设置新值的同时返回旧值，操作系统在这个指令的基础上实现锁的概念。</p><p>这个实现方式可以保证互斥，但是不能保证公平，性能也比较差，存在浪费 CPU 的情况（一直循环执行 <code>Test-And-Set</code>）。</p><p>另外，一些 CPU 也提供了另一种硬件支持的原语，<code>Compare-And-Set</code> CAS，也能实现锁。</p><p>还有其他的硬件支持的指令，比如 <code>Fetch-And-Add</code></p><h3 id=just-yield>Just Yield</h3><p>在自旋锁的基础上优化性能，对于没获取到锁的线程，让出自己的 CPU，然后等待已经获取锁的线程使用完后释放锁，主动唤醒正在等待的线程。</p><p>问题是，并不能解决饥饿问题，存在线程反复获取锁然后释放，导致另一些线程一直等待的问题。</p><h3 id=等待队列>等待队列</h3><p>解决上一种实现方式的问题，没获取到锁的线程排队进入一个队列里，获取了锁的线程释放锁时，唤醒队列中第一个线程，避免无尽等待。需要操作系统提供支持，<code>park()</code> 用来让出 CPU 并睡眠，<code>unpark(pid)</code> 用来唤醒指定线程。</p><h3 id=两阶段锁>两阶段锁</h3><p>进一步优化，第一阶段尝试自旋获取锁，如果在执行时间内没有获取到锁，再进入等待队列。</p><h2 id=锁相关的数据结构>锁相关的数据结构</h2><h3 id=并发计数器>并发计数器</h3><p>多个线程同时执行加法计算，由于要保证并发安全，需要加锁，那么多线程执行时的速度就很慢。理论上，多线程应该要比单线程要快，实际可能并非如此。</p><p>通过多核 CPU 同时执行，能够提升相应的性能，叫做完美扩展，比如原来单个 CPU 需要 1s 完成的任务，任务量扩大了 3 倍，3 个 CPU 同时执行，还是只需要 1s 就能完成。</p><p>近似计数器几乎能做到完美扩展，实现方式是每个处理器上都有个计数器，然后有一个总计数器，每个处理器只执行自己上面的计数器值，定期同步到总计数器上，锁的话有两种，一种是每个处理器局部的锁，另一种是总计数器的锁。近似处理器的性能取决于“定期同步”的阈值，定期同步越频繁，性能越低。</p><h3 id=并发链表>并发链表</h3><p>实现中注意，插入一个链表元素时需要申请内存，申请内存可能失败，如果申请内存失败了，不能还持有锁，将加锁代码放在内存申请之后即可。</p><h3 id=并发队列>并发队列</h3><p>一个经典的实现，头尾指针各有一把锁，入队出队可以并发执行，另外使用了一个小技巧，一个占位结点作为头结点，避免了代码中判断头尾指针是否为空的问题。</p><h3 id=并发哈希表>并发哈希表</h3><p>借用了并发链表实现，即使用了链地址法。在每个桶上执行了加锁，降低了锁粒度。</p><p>在并发编程中，要避免提前优化，“过早的优化是万恶之源”，不仅在并发编程中，日常编程也是。</p></div><div class=post-footer></div></article></main></body></html>