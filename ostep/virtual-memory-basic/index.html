<!doctype html><html lang=en-us><head><title>OSTEP 读书笔记: 内存虚拟化之基础知识 // RojerAlone</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="RojerAlone"><meta name=description content><link rel=stylesheet href=https://rojeralone.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','G-T1VNZF1VBZ','auto'),ga('send','pageview'))</script><meta name=twitter:card content="summary"><meta name=twitter:title content="OSTEP 读书笔记: 内存虚拟化之基础知识"><meta name=twitter:description content="内存虚拟化 - 基础知识 地址空间 操作系统为虚拟内存提供的抽象叫做地址空间(Address Space)，是运行中的进程能够看到的内存空间。进程申请内存主要用作 3 种数据的存储：代码、堆、栈。每个进程看到的地址空间都是一样的，给进程一种自己拥有所有内存的假象，而在真正的物理内存上，实现了进程隔离，保证了内存操作的安全性。
目标 内存虚拟化的目标：
 透明 高效 保护：进程之间不能互相访问对方的内存空间  内存操作 API 一个进程会显示申请两种类型的内存，栈和堆。栈内存由编译器隐式帮程序员申请了，并且在生命周期结束后隐式释放，如果要将该内存在生命周期之外使用，则要分配堆内存，内存管理主要关注堆内存。
malloc() void *malloc(size_t size) 申请大小为 size 的内存空间，返回指向这块内存空间的指针，一般使用类型转换转化为目标类型。size 一般使用 sizeof() 操作获取，因为在不同的平台上大小可能不一样，编译器会解析 sizeof() 的结果，而不是在运行时才解析。
free() 释放内存，把 malloc 返回的指针传进去就行，内存分配器会知道释放多少内存的，不需要显示传进去。
使用注意事项  未分配内存：一些函数的指针参数是非空指针，比如 strcpy 未分配足够的内存：还是 strcpy，报错与否是不确定的 未初始化申请的内存：里边的内容是不确定的 未释放申请的内存：导致内存泄漏 提前释放了还在使用的内存：野指针 / 悬浮指针 重复释放内存：不可预知的后果，大部分是崩溃 错误调用 free(): 释放了未知的内存  系统调用 malloc() 和 free() 并不是系统调用，而是内存分配库提供的功能，这些库的底层依赖了系统调用 brk 和 sbrk，程序员不应该直接调用这些方法，除非你很清楚你在做什么，另外还可以通过 mmap 来分配内存，这是个系统调用。
内存分配库还提供一些其他调用，比如 calloc() 分配全是 0 的内存，realloc() 传入一个内存指针，返回一个更大的但是已经将旧内存 copy 过去的新内存地址。
地址转换 内存的虚拟化和 CPU 的虚拟化追求的目标一致：效率和控制。"><meta property="og:title" content="OSTEP 读书笔记: 内存虚拟化之基础知识"><meta property="og:description" content="内存虚拟化 - 基础知识 地址空间 操作系统为虚拟内存提供的抽象叫做地址空间(Address Space)，是运行中的进程能够看到的内存空间。进程申请内存主要用作 3 种数据的存储：代码、堆、栈。每个进程看到的地址空间都是一样的，给进程一种自己拥有所有内存的假象，而在真正的物理内存上，实现了进程隔离，保证了内存操作的安全性。
目标 内存虚拟化的目标：
 透明 高效 保护：进程之间不能互相访问对方的内存空间  内存操作 API 一个进程会显示申请两种类型的内存，栈和堆。栈内存由编译器隐式帮程序员申请了，并且在生命周期结束后隐式释放，如果要将该内存在生命周期之外使用，则要分配堆内存，内存管理主要关注堆内存。
malloc() void *malloc(size_t size) 申请大小为 size 的内存空间，返回指向这块内存空间的指针，一般使用类型转换转化为目标类型。size 一般使用 sizeof() 操作获取，因为在不同的平台上大小可能不一样，编译器会解析 sizeof() 的结果，而不是在运行时才解析。
free() 释放内存，把 malloc 返回的指针传进去就行，内存分配器会知道释放多少内存的，不需要显示传进去。
使用注意事项  未分配内存：一些函数的指针参数是非空指针，比如 strcpy 未分配足够的内存：还是 strcpy，报错与否是不确定的 未初始化申请的内存：里边的内容是不确定的 未释放申请的内存：导致内存泄漏 提前释放了还在使用的内存：野指针 / 悬浮指针 重复释放内存：不可预知的后果，大部分是崩溃 错误调用 free(): 释放了未知的内存  系统调用 malloc() 和 free() 并不是系统调用，而是内存分配库提供的功能，这些库的底层依赖了系统调用 brk 和 sbrk，程序员不应该直接调用这些方法，除非你很清楚你在做什么，另外还可以通过 mmap 来分配内存，这是个系统调用。
内存分配库还提供一些其他调用，比如 calloc() 分配全是 0 的内存，realloc() 传入一个内存指针，返回一个更大的但是已经将旧内存 copy 过去的新内存地址。
地址转换 内存的虚拟化和 CPU 的虚拟化追求的目标一致：效率和控制。"><meta property="og:type" content="article"><meta property="og:url" content="https://rojeralone.github.io/ostep/virtual-memory-basic/"><meta property="article:section" content="ostep"><meta property="article:published_time" content="2021-06-23T20:14:15+08:00"><meta property="article:modified_time" content="2021-06-23T20:14:15+08:00"></head><body><header class=app-header><a href=https://rojeralone.github.io/><img class=app-header-avatar src=/avatar.jpg alt=RojerAlone></a><h1>RojerAlone</h1><p>Developer</p><div class=app-header-social><a href=https://github.com/RojerAlone target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>OSTEP 读书笔记: 内存虚拟化之基础知识</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 23, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://rojeralone.github.io/tags/ostep/>ostep</a>
<a class=tag href=https://rojeralone.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div></div></header><div class=post-content><h1 id=内存虚拟化---基础知识>内存虚拟化 - 基础知识</h1><h2 id=地址空间>地址空间</h2><p>操作系统为虚拟内存提供的抽象叫做地址空间(Address Space)，是运行中的进程能够看到的内存空间。进程申请内存主要用作 3 种数据的存储：代码、堆、栈。每个进程看到的地址空间都是一样的，给进程一种自己拥有所有内存的假象，而在真正的物理内存上，实现了进程隔离，保证了内存操作的安全性。</p><h2 id=目标>目标</h2><p>内存虚拟化的目标：</p><ul><li>透明</li><li>高效</li><li>保护：进程之间不能互相访问对方的内存空间</li></ul><h2 id=内存操作-api>内存操作 API</h2><p>一个进程会显示申请两种类型的内存，栈和堆。栈内存由编译器隐式帮程序员申请了，并且在生命周期结束后隐式释放，如果要将该内存在生命周期之外使用，则要分配堆内存，内存管理主要关注堆内存。</p><h3 id=malloc>malloc()</h3><p><code>void *malloc(size_t size)</code> 申请大小为 size 的内存空间，返回指向这块内存空间的指针，一般使用类型转换转化为目标类型。size 一般使用 <code>sizeof()</code> 操作获取，因为在不同的平台上大小可能不一样，编译器会解析 <code>sizeof()</code> 的结果，而不是在运行时才解析。</p><h3 id=free>free()</h3><p>释放内存，把 <code>malloc</code> 返回的指针传进去就行，内存分配器会知道释放多少内存的，不需要显示传进去。</p><h3 id=使用注意事项>使用注意事项</h3><ul><li>未分配内存：一些函数的指针参数是非空指针，比如 <code>strcpy</code></li><li>未分配足够的内存：还是 <code>strcpy</code>，报错与否是不确定的</li><li>未初始化申请的内存：里边的内容是不确定的</li><li>未释放申请的内存：导致内存泄漏</li><li>提前释放了还在使用的内存：野指针 / 悬浮指针</li><li>重复释放内存：不可预知的后果，大部分是崩溃</li><li>错误调用 <code>free()</code>: 释放了未知的内存</li></ul><h3 id=系统调用>系统调用</h3><p><code>malloc()</code> 和 <code>free()</code> 并不是系统调用，而是内存分配库提供的功能，这些库的底层依赖了系统调用 <code>brk</code> 和 <code>sbrk</code>，程序员不应该直接调用这些方法，除非你很清楚你在做什么，另外还可以通过 <code>mmap</code> 来分配内存，这是个系统调用。</p><p>内存分配库还提供一些其他调用，比如 <code>calloc()</code> 分配全是 0 的内存，<code>realloc()</code> 传入一个内存指针，返回一个更大的但是已经将旧内存 copy 过去的新内存地址。</p><h2 id=地址转换>地址转换</h2><p>内存的虚拟化和 CPU 的虚拟化追求的目标一致：效率和控制。</p><p>操作系统借用硬件实现高效的地址转化，操作系统本身只管理内存分配，它需要知道哪些内存分配了哪些没分配。</p><p>和任务调度一样，我们先假设几个条件，然后逐步放松这个条件，最终实现一个实际的 VM 系统：</p><ol><li>每个进程的地址空间都是连续的</li><li>进程的地址空间都不大，小于实际物理内存</li><li>每个进程地址空间一样大</li></ol><p>例子这里略过，问题是：对进程来说，它的地址空间是从 0 开始，但是实际物理内存中，该进程并不从 0 开始，怎么把寻址透明化，给进程一个假象它就是从 0 开始使用的？</p><h3 id=动态重定位-dynamic-relocation>动态重定位 Dynamic Relocation</h3><p>在每个 CPU 中有两个硬件的寄存器：base 和 bound，分别用来记录进程地址空间的起始地址和该进程地址空间的总大小，比如某个进程的地址空间是 16KB，实际的物理地址在 32KB 到 48KB 之间，那么 base 就是 32KB，bound 是 16KB。进程请求访问自己的第 2KB，实际访问的物理地址是 base + target_position = 34 KB。bound 能够保证进程访问的地址空间不超过自己应该访问的区域。</p><p>这种在 CPU 里的寻址硬件成为 MMU(Memory Management Unit)，随着使用更复杂的寻址机制，MMU 的电路也更复杂。</p><p>为了支持这种硬件层面的地址转化，需要一些额外的硬件支持：</p><ul><li>地址转化并检查是否越界</li><li>支持特权模式，只有在内核模式才能修改 base / bound</li><li>预期外的修改应该能抛出异常并处理</li></ul><p>在硬件支持之上，操作系统负责一系列的操作：</p><ol><li>分配内存，操作系统需要知道哪里有空闲的内存</li><li>进程退出时回收内存</li><li>上下文切换时保存进程的 vm 信息，比如上文提到的 base 和 bound，而当进程重新调度的时候重新设置 vm 信息</li><li>异常处理，访问越界的内存时应该抛出异常，由系统启动时注册的异常处理器进行处理</li></ol><p>Dynamic Relocation 技术有它的局限性，它太过简单了，限制也太多了，由于分配的内存进程不一定用到，有内部碎片浪费的问题。</p><h2 id=内存分段>内存分段</h2><p>base-and-bound 机制的问题是，虚拟内存申请了多大，实际的物理内存就占用了多大，当进程的地址空间越大，浪费也就越严重。</p><p>1960 年代提出的分段机制，将地址空间分为多个特定大小的 segment，每个 segment 都有一个 base / bound 对，来表示段地址空间。</p><p>分段也有单独的寄存器支持，叫做段寄存器。通常一个程序有 3 个分段：代码段、内存段、栈段，段寄存器如果知道这是一个什么类型的段？一种常见方式是使用虚拟地址的前 2 个 bit 做标识，比如 00 是代码段，该地址除去前 2 个 bit 的数字为段内的 offset，这样就知道去哪个段的多长的位置取数据了。有些系统也会将代码段和内存段合二为一，这样虚拟地址只需要用 1 bit 就能区分不同的段了。还有一种隐式的方式，通过判断是谁发送的寻址请求，来判断去哪个段取信息，比如程序计数器取得是代码段，基于栈的请求地址一定在栈段，剩余的在堆段。</p><p>上面忽略了一个问题，堆和栈的寻址方向是相反的，从地址空间两边往中间增长，那么在寻址时需要判断应该往哪个方向寻址，可以新增加一个标识位，1 表示往高地址寻址，0 表示往低地址寻址。</p><h3 id=共享内存支持>共享内存支持</h3><p>在分段的基础上可以实现共享内存，以节省内存，需要一个额外的支持，保护位，用来标识这个段的权限，比如一些 <code>.so</code> 库是可以读并且执行的，但是不能写，而进程自己的堆和栈是可读可写的。有了保护位，硬件就又要做些支持了，需要判断是否可操作该地址。</p><h3 id=段的粗细粒度>段的粗细粒度</h3><p>上面说的都是进程只有 3 个段，这个粒度是比较粗的粒度，还可以支持更细的粒度（后面的 page），那么一个进程就要包含更多的段，需要硬件更多的支持，操作系统还要有段表，知道哪个段在用哪个没用。</p><h3 id=操作系统的责任>操作系统的责任</h3><p>到现在已经大致知道内存段的原理了，内存分段也带来了一些问题：</p><ul><li>上下文切换时操作系统应该保存停止进程的段信息，写入调度进程的段信息</li><li>段增长时操作系统的交互，应该扩增段的大小，当前段前后没有空间时要找到可用的足够大的物理内存，然后把数据迁移过去，如果内存不够也应该拒绝请求</li><li>最重要的问题是管理空闲的物理内存，当新的地址空间创建的时候，操作系统需要找到物理内存分配给地址空间使用，但是段地址不是固定大小的，也不是连续的，会导致产生很多不连续的小的内存碎片，导致很难分配或者让已有的段扩容，这个问题成为外部碎片。解决办法是找到更大的空闲内存，把之前的给移过去，但是移动内存是消耗很大的。当然也可以整理碎片，但是也是消耗巨大的。更简单的做法是维护一个空闲内存列表，尽量分配小内存，还有其他各种算法，但是都无法完全消除碎片，只是尽量减少碎片。</li></ul><h2 id=空闲空间管理>空闲空间管理</h2><p>如果按照固定大小管理空间（比如分页），只需要维护一个 page list 就够了，但是如果要管理的是不固定的大小，问题就困难了很多。</p><p>这里主要关注非定长的空间，更倾向于用户使用层面的内存分配库，比如提供 <code>malloc()</code> 和 <code>free()</code> 的库。</p><h3 id=假设>假设</h3><p>内存分配库管理的是堆内存，空闲空间管理的通用数据结构是空闲列表，列表中包含了所有空闲的内存块，重要的不是实现一个列表，而是跟踪空闲空间的数据结构。</p><p>进一步假设更关注的是外部碎片。如果分配了内存，但是进程没有完全使用，那么这是进程自身的浪费，是进程内部的碎片，而分配器剩余的无法分配的碎片称为外部碎片。这两种碎片外部碎片更有趣，所以更关注的是它。</p><p>还假设只要分配出去的内存就不会再变化，不做 compaction，直到进程主动释放。</p><p>最后，假设内存分配器管理的是一块固定大小的内存，不会再扩增或缩小。</p><h3 id=基础机制>基础机制</h3><p>首先讨论一些基本的机制，在各种内存分配器中都很常用的技术。</p><h4 id=分割和合并>分割和合并</h4><ul><li>分割：在空闲列表中，当请求一个很小的空间时，分割一个已有的空闲空间，返回给用户指定的空间，剩下的空间仍然在列表中</li><li>合并：当返还空间时，看下返还空间挨着的是不是空闲空间，是的话合并</li></ul><h4 id=跟踪已分配的区域的大小>跟踪已分配的区域的大小</h4><p>用户调用 <code>free()</code> 时没有传入 size，需要内存分配器能够知道返还了多少空间。实现机制是在分配内存空间时不是分配指定的大小，而是在分配的空间之前加入了 <strong>header</strong>，包含 <code>size</code> 和 <code>magic_number</code>。比如分配 20 byte 的内存，实际分配了 28 byte，前 4 个 byte 用来保存 size，中间 4 个 byte 是 magic_nuber，最后的 20 byte 才是分配给用户的内存，返回的指针是 8 而不是 0。另外，分配内存的时候从空闲列表中寻找 28 byte 的空闲空间而不是 20 byte。</p><h4 id=内嵌的空闲列表>内嵌的空闲列表</h4><p>内存分配器也需要内存来保存空闲列表，回到了先有鸡还是先有蛋的问题，它应该怎么申请内存？</p><p>空闲列表的数据结构为链表，链表结构为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> __node_t {
  <span style=color:#66d9ef>int</span>							size;  <span style=color:#75715e>// 当前块的大小
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> __node_t <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 下一个块的地址
</span><span style=color:#75715e></span>}
</code></pre></div><p>书上比较详细讲了内存分配并且释放之后的图，用一句话概括：内存是一个一个的块，已分配的块结构为 size / magic_number / data，空闲块的结构为 size / next_free_space_addr / free_space，可以看成是一个抽象内存块的两种不同实现。</p><h4 id=堆扩容>堆扩容</h4><p>向操作系统申请更多的内存，然后管理这些内存。</p><h3 id=基础策略>基础策略</h3><ul><li>Best Fit：在能找到的足够大的空闲块中返回一个最小的，缺点是比较慢</li><li>Worst Fit: 和 Best Fit 相反，找到最大的，然后分割，缺点是产生碎片</li><li>First Fit: 第一个合适的，缺点是空闲列表的前边都是小碎片，一种优化措施是列表按照地址排序，这样返还内存的时候就能合并碎片</li><li>Next Fit: 额外维护一个指针，指向上次找到的空闲块，下次从这个块开始搜索，这样碎片就不总是在头部，而是均匀分布</li></ul><h3 id=一些其他实现>一些其他实现</h3><h4 id=隔离列表>隔离列表</h4><p>如果程序总是申请某个或某些固定大小的空间，那么就为这些请求单独搞个列表出来，其余的普通请求走普通分配器的逻辑。那么应该给这个特殊的分配器分配多大的内存？Solaris kernel 使用的 slab allocator 以一种很好的方式实现了，在内核启动的时候，就预分配一些内核常用的空间，比如锁、inode 对象。如果这些快用尽了，就向通用分配器再申请一些内存，相反，如果使用率比较低，通用分配器也可以从这些特定分配器中拿走一些内存。上面这种方式通过提前申请内存并初始化，减少了频繁申请内存并初始化的开销。</p><h4 id=伙伴分配>伙伴分配</h4><p>伙伴分配的目的是简化释放内存后合并碎片的逻辑。分配器总是分配 2 的幂次方的内存，比如 1KB、2KB、4KB，而不会直接分配 3KB 的内存，即使用户申请的是 3KB，所以会有内部碎片的问题。当用户申请内存的时候，会将空闲内存递归地一分为二。当用户返还内存的时候，跟它相邻的内存（伙伴）大小是一样的，而且很容易计算它的伙伴地址，因为它俩的地址在二进制只有一位不同。</p><h4 id=其他实现>其他实现</h4><p>上面提到的分配器缺点都是扩展性较差，空闲块太多时性能很差，所以现代的分配器都使用了比较复杂高效的数据结构，比如二叉搜索树等。另外，为了考虑多线程环境的使用，还会针对性优化。</p></div><div class=post-footer></div></article></main></body></html>