<!doctype html><html lang=en-us><head><title>OSTEP 读书笔记: 并发之条件变量和信号量 // RojerAlone</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="RojerAlone"><meta name=description content><link rel=stylesheet href=https://rojeralone.cn/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','G-T1VNZF1VBZ','auto'),ga('send','pageview'))</script><meta name=twitter:card content="summary"><meta name=twitter:title content="OSTEP 读书笔记: 并发之条件变量和信号量"><meta name=twitter:description content="条件变量 线程可以使用一个变量来表示条件，当这个条件为 true 时，线程可以执行，否则需要等待，这就是条件变量。
POSIX 定义了条件变量的原语：pthread_cond_wait 和 pthread_cond_signal，通常叫做 wait() 和 signal()。
一般条件变量和锁一起使用，pthread_cond_wait 的参数就有个锁变量，持有锁的线程调用 wait() 释放锁，并等待唤醒，获取锁的线程调用 signal() 唤醒等待的线程，被唤醒的线程需要等待锁被释放，并且自己获取到锁以后再继续往下执行。
为了更好理解条件变量的含义和用法，使用生产/消费者模型，或者叫有界缓冲区来帮助读者掌握。
生产/消费者问题 初始版本是非常粗糙的实现，缓冲区只能存放一个元素，put / get 时分别需要判断队列是否满了或者空了。
问题1：生产者消费者两个线程执行，很容易就遇到不满足判断条件的情况。
优化1：使用条件变量。生产/消费前先获取锁，然后判断缓冲区的容量，如果不满足要求，就释放锁，等待条件变量满足后被唤醒。
这样的优化在生产者和消费者都是单线程的情况下可以 work，但是如果消费者有 2 个，就会出现这样的情况：消费者 A 消费完后，唤醒了消费者 B，B 去消费，发现没有数据，get 失败了。
问题2: 如果有多个消费者会出现被唤醒后，获取不到数据的情况
优化2: 判断满足条件时，应该使用 while 循环判断，而不是 if，也就是 wait 等待的代码块应该在循环中，不是在 if 代码块中，这样被唤醒后再次判断条件是否满足，不满足继续睡眠等待。
优化后还是有些小问题，当消费者消费完成后，唤醒的是另一个消费者，它发现队列是空的，就又陷入睡眠，这样并不是效率很高的执行方式，正确的操作是唤醒生产者，让它继续往队列里生产数据。
问题3: 效率低，消费空队列后没唤醒生产者
优化3: 使用两个条件变量，消费者等待队列中有数据的条件变量，生产者等待队列不满的条件变量。
当缓冲区的大小只有 1 时，效率不是那么高，正常情况下也不会消费队列不会这么小。
问题4: 缓冲区小，性能不够高
优化4: 增大缓冲区，使用变量记录缓冲区大小，当缓冲区没满时生产者就一直生产，缓冲区不空消费者就一直消费。
唤醒所有线程 上述问题 3 还有另一种解法，只用一个条件变量， 但是唤醒等待线程时不是只唤醒一个，而是唤醒所有的等待线程，这样就一定能够唤醒该唤醒的线程，不该唤醒的线程会影响性能，它们只检查条件，然后又陷入沉睡，这种能覆盖需要唤醒线程的场景叫做覆盖条件。
一些想法 书中描述条件变量的唤醒时，只是说唤醒睡眠的线程，并没有详细描述怎么实现的，根据查资料以及个人的理解，signal() 并不是”真正“唤醒了线程，而是把线程从一个不可被调度器调度的状态，转为了可执行，但是在等待锁的状态，一般是从一个等待队列换到了竞争锁的队列中，直到调用 signal() 的线程释放锁，等待锁的线程竞争锁，如果被”唤醒“的线程竞争到了锁，那么它才真正被唤醒，继续接着 wait() 之后的代码执行，否则继续等待竞争锁。
信号量 信号量是一个有计数的变量，sem_wait() 和 sem_post() 是操作信号量的两个指令，信号量初始化时可以执行计数的值，当计数值为负数时，表示有多少个线程在等待信号，否则，线程获取到了信号，可以立马执行。"><meta property="og:title" content="OSTEP 读书笔记: 并发之条件变量和信号量"><meta property="og:description" content="条件变量 线程可以使用一个变量来表示条件，当这个条件为 true 时，线程可以执行，否则需要等待，这就是条件变量。
POSIX 定义了条件变量的原语：pthread_cond_wait 和 pthread_cond_signal，通常叫做 wait() 和 signal()。
一般条件变量和锁一起使用，pthread_cond_wait 的参数就有个锁变量，持有锁的线程调用 wait() 释放锁，并等待唤醒，获取锁的线程调用 signal() 唤醒等待的线程，被唤醒的线程需要等待锁被释放，并且自己获取到锁以后再继续往下执行。
为了更好理解条件变量的含义和用法，使用生产/消费者模型，或者叫有界缓冲区来帮助读者掌握。
生产/消费者问题 初始版本是非常粗糙的实现，缓冲区只能存放一个元素，put / get 时分别需要判断队列是否满了或者空了。
问题1：生产者消费者两个线程执行，很容易就遇到不满足判断条件的情况。
优化1：使用条件变量。生产/消费前先获取锁，然后判断缓冲区的容量，如果不满足要求，就释放锁，等待条件变量满足后被唤醒。
这样的优化在生产者和消费者都是单线程的情况下可以 work，但是如果消费者有 2 个，就会出现这样的情况：消费者 A 消费完后，唤醒了消费者 B，B 去消费，发现没有数据，get 失败了。
问题2: 如果有多个消费者会出现被唤醒后，获取不到数据的情况
优化2: 判断满足条件时，应该使用 while 循环判断，而不是 if，也就是 wait 等待的代码块应该在循环中，不是在 if 代码块中，这样被唤醒后再次判断条件是否满足，不满足继续睡眠等待。
优化后还是有些小问题，当消费者消费完成后，唤醒的是另一个消费者，它发现队列是空的，就又陷入睡眠，这样并不是效率很高的执行方式，正确的操作是唤醒生产者，让它继续往队列里生产数据。
问题3: 效率低，消费空队列后没唤醒生产者
优化3: 使用两个条件变量，消费者等待队列中有数据的条件变量，生产者等待队列不满的条件变量。
当缓冲区的大小只有 1 时，效率不是那么高，正常情况下也不会消费队列不会这么小。
问题4: 缓冲区小，性能不够高
优化4: 增大缓冲区，使用变量记录缓冲区大小，当缓冲区没满时生产者就一直生产，缓冲区不空消费者就一直消费。
唤醒所有线程 上述问题 3 还有另一种解法，只用一个条件变量， 但是唤醒等待线程时不是只唤醒一个，而是唤醒所有的等待线程，这样就一定能够唤醒该唤醒的线程，不该唤醒的线程会影响性能，它们只检查条件，然后又陷入沉睡，这种能覆盖需要唤醒线程的场景叫做覆盖条件。
一些想法 书中描述条件变量的唤醒时，只是说唤醒睡眠的线程，并没有详细描述怎么实现的，根据查资料以及个人的理解，signal() 并不是”真正“唤醒了线程，而是把线程从一个不可被调度器调度的状态，转为了可执行，但是在等待锁的状态，一般是从一个等待队列换到了竞争锁的队列中，直到调用 signal() 的线程释放锁，等待锁的线程竞争锁，如果被”唤醒“的线程竞争到了锁，那么它才真正被唤醒，继续接着 wait() 之后的代码执行，否则继续等待竞争锁。
信号量 信号量是一个有计数的变量，sem_wait() 和 sem_post() 是操作信号量的两个指令，信号量初始化时可以执行计数的值，当计数值为负数时，表示有多少个线程在等待信号，否则，线程获取到了信号，可以立马执行。"><meta property="og:type" content="article"><meta property="og:url" content="https://rojeralone.cn/ostep/concurrency-condition-variable-and-semaphore/"><meta property="article:section" content="ostep"><meta property="article:published_time" content="2021-08-01T17:39:19+08:00"><meta property="article:modified_time" content="2021-08-01T17:39:19+08:00"></head><body><header class=app-header><a href=https://rojeralone.cn/><img class=app-header-avatar src=/avatar.jpg alt=RojerAlone></a><h1>RojerAlone</h1><p>Developer</p><div class=app-header-social><a href=https://github.com/RojerAlone target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>OSTEP 读书笔记: 并发之条件变量和信号量</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Aug 1, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://rojeralone.cn/tags/ostep/>ostep</a>
<a class=tag href=https://rojeralone.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div></div></header><div class=post-content><h1 id=条件变量>条件变量</h1><p>线程可以使用一个变量来表示条件，当这个条件为 true 时，线程可以执行，否则需要等待，这就是条件变量。</p><p>POSIX 定义了条件变量的原语：<code>pthread_cond_wait</code> 和 <code>pthread_cond_signal</code>，通常叫做 <code>wait()</code> 和 <code>signal()</code>。</p><p>一般条件变量和锁一起使用，<code>pthread_cond_wait</code> 的参数就有个锁变量，持有锁的线程调用 <code>wait()</code> 释放锁，并等待唤醒，获取锁的线程调用 <code>signal()</code> 唤醒等待的线程，被唤醒的线程需要等待锁被释放，并且自己获取到锁以后再继续往下执行。</p><p>为了更好理解条件变量的含义和用法，使用生产/消费者模型，或者叫有界缓冲区来帮助读者掌握。</p><h2 id=生产消费者问题>生产/消费者问题</h2><p>初始版本是非常粗糙的实现，缓冲区只能存放一个元素，<code>put</code> / <code>get</code> 时分别需要判断队列是否满了或者空了。</p><p><strong>问题1</strong>：生产者消费者两个线程执行，很容易就遇到不满足判断条件的情况。</p><p><strong>优化1</strong>：使用条件变量。生产/消费前先获取锁，然后判断缓冲区的容量，如果不满足要求，就释放锁，等待条件变量满足后被唤醒。</p><p>这样的优化在生产者和消费者都是单线程的情况下可以 work，但是如果消费者有 2 个，就会出现这样的情况：消费者 A 消费完后，唤醒了消费者 B，B 去消费，发现没有数据，<code>get</code> 失败了。</p><p><strong>问题2</strong>: 如果有多个消费者会出现被唤醒后，获取不到数据的情况</p><p><strong>优化2</strong>: 判断满足条件时，应该使用 <code>while</code> 循环判断，而不是 <code>if</code>，也就是 <code>wait</code> 等待的代码块应该在循环中，不是在 <code>if</code> 代码块中，这样被唤醒后再次判断条件是否满足，不满足继续睡眠等待。</p><p>优化后还是有些小问题，当消费者消费完成后，唤醒的是另一个消费者，它发现队列是空的，就又陷入睡眠，这样并不是效率很高的执行方式，正确的操作是唤醒生产者，让它继续往队列里生产数据。</p><p><strong>问题3</strong>: 效率低，消费空队列后没唤醒生产者</p><p><strong>优化3</strong>: 使用两个条件变量，消费者等待队列中有数据的条件变量，生产者等待队列不满的条件变量。</p><p>当缓冲区的大小只有 1 时，效率不是那么高，正常情况下也不会消费队列不会这么小。</p><p><strong>问题4</strong>: 缓冲区小，性能不够高</p><p><strong>优化4</strong>: 增大缓冲区，使用变量记录缓冲区大小，当缓冲区没满时生产者就一直生产，缓冲区不空消费者就一直消费。</p><h2 id=唤醒所有线程>唤醒所有线程</h2><p>上述问题 3 还有另一种解法，只用一个条件变量， 但是唤醒等待线程时不是只唤醒一个，而是唤醒所有的等待线程，这样就一定能够唤醒该唤醒的线程，不该唤醒的线程会影响性能，它们只检查条件，然后又陷入沉睡，这种能覆盖需要唤醒线程的场景叫做<strong>覆盖条件</strong>。</p><h2 id=一些想法>一些想法</h2><p>书中描述条件变量的唤醒时，只是说唤醒睡眠的线程，并没有详细描述怎么实现的，根据查资料以及个人的理解，<code>signal()</code> 并不是”真正“唤醒了线程，而是把线程从一个不可被调度器调度的状态，转为了可执行，但是在等待锁的状态，一般是从一个等待队列换到了竞争锁的队列中，直到调用 <code>signal()</code> 的线程释放锁，等待锁的线程竞争锁，如果被”唤醒“的线程竞争到了锁，那么它才真正被唤醒，继续接着 <code>wait()</code> 之后的代码执行，否则继续等待竞争锁。</p><h1 id=信号量>信号量</h1><p>信号量是一个有计数的变量，<code>sem_wait()</code> 和 <code>sem_post()</code> 是操作信号量的两个指令，信号量初始化时可以执行计数的值，当计数值为负数时，表示有多少个线程在等待信号，否则，线程获取到了信号，可以立马执行。</p><p>也就是，计数值大于 0，调用 <code>sem_wait()</code> 可以不被阻塞，同时计数值 -1，否则被阻塞；未被阻塞的线程执行完毕后，要调用 <code>sem_post()</code> 释放信号，计数值 +1，并唤醒等待执行的线程。</p><h2 id=二值信号量>二值信号量</h2><p>二值信号量是计数值为 1 的信号量，功能和锁一样，当一个线程 A 调用 <code>sem_wait()</code>，计数值变为 0，此线程不被阻塞。这时另一个线程 B 调用 <code>sem_wait()</code>，计数值变为 -1，线程 B 被阻塞。线程 A 完成逻辑后调用 <code>sem_post()</code>，计数值 +1 变为 0，唤醒等待的线程 B，线程 B 执行完后调用 <code>sem_post()</code>，计数值重新变为 1。</p><p>可见，可以通过信号量实现锁的功能。</p><h2 id=信号量作为条件变量>信号量作为条件变量</h2><p>将信号量的计数值设置为 0，即初始时调用 <code>sem_wait()</code> 的话会被阻塞，直到 <code>sem_post()</code> 被调用时才能继续执行，也就是条件变量的条件是 <code>sem_post()</code> 被调用。</p><h2 id=生产者消费者问题>生产者/消费者问题</h2><p>上一章条件变量时的生产者消费者问题在这里又出现了，这次使用信号量解决。</p><p>在上一章的基础之上，初始版本使用两个信号量，一个是缓冲区满的信号量，计数值初始为 0，一个是缓冲区空的信号量，计数值初始为缓冲区的大小。</p><p>生产者先调用 <code>sem_wait(&empty)</code>，生产过后调用 <code>sem_post(&full)</code> ，可以认为 <code>full</code> 是缓冲区目前的消息数。</p><p>问题在于没加锁，生产者生产一条消息后被中断，此时缓冲区数组的索引还未移动，另一个生产者也生产了一条消息，刚才生产的消息就丢了。</p><p>解决办法是加上锁，生产消费都加锁。又产生了死锁问题，获取了锁之后再调用信号量，解决方法是调换顺序，只有确定可以往缓冲区读写以后再尝试获取锁。</p><h2 id=读写锁>读写锁</h2><p>实现方式是读写锁本身有一把锁，然后写单独一把锁，有个计数值表示读锁加了多少次。无论读写锁都要获取写锁，是为了读写互斥，只有读锁计数为 0 时才完全释放读锁，同时唤醒等待写锁的线程。</p><h2 id=哲学家就餐问题>哲学家就餐问题</h2><p>Dijkstra 提出的哲学家就餐问题，5 个哲学家 5 把刀叉，只有同时拿到两个刀叉才能吃饭，避免哲学家饿死，也就是避免死锁。</p><p>解决方式是除了最后一个哲学家以外，其他的都先拿左边的刀叉，后拿后边的刀叉，最后一个哲学家先拿右边的刀叉后拿左边的刀叉，避免循环依赖。</p><h2 id=线程限制>线程限制</h2><p>使用信号量实现 thread throttling。</p><h2 id=信号量的实现>信号量的实现</h2><p>使用 lock 和 continal variable 可以实现信号量，另外还需要一个计数值，即信号量的计数值。</p><p><code>sem_wait()</code> 时先获取锁，如果计数值不大于 0，则调用条件变量的 <code>wait()</code> ，否则计数值减一。</p><p><code>sem_post()</code> 时也先获取锁，计数值加 1 然后唤醒条件变量即可。</p></div><div class=post-footer></div></article></main></body></html>