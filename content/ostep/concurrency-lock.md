---
title: "OSTEP 读书笔记: 并发之锁"
date: 2021-07-19T23:27:08+08:00
draft: false

categories:
- 读书笔记
tags:
- ostep
- 操作系统
---

## 评估

如果评估锁的好坏？

1.  是否能够做到互斥
2.  公平性，避免饥饿
3.  性能

## 实现方式

### 控制中断

最简单的实现方式，当执行需要互斥的代码时，禁止中断。

问题：

-   禁止中断是特权操作，普通进程能执行这个操作比较危险
-   多处理器时，这种方式就不管用了
-   关掉中断可能导致比较重要的中断无法响应，甚至导致系统崩溃
-   性能很差

### Loads / Stores

用一个变量标识是否获取了锁，问题是，两个线程同时执行 `if (flag == 0) flag = 1` 这个操作，这不是个原子操作，可能会被中断，A 准备赋值为 1 时被中断了，导致另一个线程认为自己应该获取锁，那么两个线程都能获取到锁。

### Test-And-Set 自旋锁

硬件提供了 `Test-And-Set` 指令，对某个变量设置新值的同时返回旧值，操作系统在这个指令的基础上实现锁的概念。

这个实现方式可以保证互斥，但是不能保证公平，性能也比较差，存在浪费 CPU 的情况（一直循环执行 `Test-And-Set`）。

另外，一些 CPU 也提供了另一种硬件支持的原语，`Compare-And-Set` CAS，也能实现锁。

还有其他的硬件支持的指令，比如 `Fetch-And-Add`

### Just Yield

在自旋锁的基础上优化性能，对于没获取到锁的线程，让出自己的 CPU，然后等待已经获取锁的线程使用完后释放锁，主动唤醒正在等待的线程。

问题是，并不能解决饥饿问题，存在线程反复获取锁然后释放，导致另一些线程一直等待的问题。

### 等待队列

解决上一种实现方式的问题，没获取到锁的线程排队进入一个队列里，获取了锁的线程释放锁时，唤醒队列中第一个线程，避免无尽等待。需要操作系统提供支持，`park()` 用来让出 CPU 并睡眠，`unpark(pid)` 用来唤醒指定线程。

### 两阶段锁

进一步优化，第一阶段尝试自旋获取锁，如果在执行时间内没有获取到锁，再进入等待队列。

## 锁相关的数据结构



### 并发计数器

多个线程同时执行加法计算，由于要保证并发安全，需要加锁，那么多线程执行时的速度就很慢。理论上，多线程应该要比单线程要快，实际可能并非如此。

通过多核 CPU 同时执行，能够提升相应的性能，叫做完美扩展，比如原来单个 CPU 需要 1s 完成的任务，任务量扩大了 3 倍，3 个 CPU 同时执行，还是只需要 1s 就能完成。

近似计数器几乎能做到完美扩展，实现方式是每个处理器上都有个计数器，然后有一个总计数器，每个处理器只执行自己上面的计数器值，定期同步到总计数器上，锁的话有两种，一种是每个处理器局部的锁，另一种是总计数器的锁。近似处理器的性能取决于“定期同步”的阈值，定期同步越频繁，性能越低。

### 并发链表

实现中注意，插入一个链表元素时需要申请内存，申请内存可能失败，如果申请内存失败了，不能还持有锁，将加锁代码放在内存申请之后即可。

### 并发队列

一个经典的实现，头尾指针各有一把锁，入队出队可以并发执行，另外使用了一个小技巧，一个占位结点作为头结点，避免了代码中判断头尾指针是否为空的问题。

### 并发哈希表

借用了并发链表实现，即使用了链地址法。在每个桶上执行了加锁，降低了锁粒度。



在并发编程中，要避免提前优化，“过早的优化是万恶之源”，不仅在并发编程中，日常编程也是。
