---
title: "OSTEP 读书笔记: 文件系统实现"
date: 2021-08-12T19:40:09+08:00
draft: false

categories:
- 读书笔记
tags:
- ostep
- 操作系统
---

# 文件和文件夹

操作系统对文件系统的关键抽象就是文件和文件夹。

文件是线性字节数组组成的一个整体，用户可以进行读写。每个文件还有一个低级别的名字，通常用一个数字表示，用户一般对这个名字无感知，由于历史原因，这个名字通常叫做 **inode**。

文件夹和文件类似，也有一个 inode，但是它的内容不是二进制字节数据，而是包含了文件夹和文件的列表，即它只是容器，不直接保存数据，而是保存其他文件夹和文件。文件系统通常有个 root directory，在 Unix 系统中是 /。通过 / 分割多层级的文件夹，可以得到一个文件夹树，文件夹树中的每个文件或文件夹都可以用路径表示，文件系统也通过路径操作对应的文件或文件夹。

## 文件系统接口

### create

`open()` 命令打开文件，通过传入 `O_CREATE` 参数创建文件，`open` 命令返回一个数字，称为 **fd** (file descriptor)，fd 是进程私有的，对文件的操作都通过 fd 进行，每个进程内部都有一个 **open file table** 表示打开的文件。

### read and write

上面说到对文件的操作要通过 fd 进行，读写文件的指令都需要传入 fd，`read` 和 `write` 返回读写了多少字节的数据。

`strace` 命令可以跟踪操作进行的系统调用，通过 `strace cat xxx` 命令，看到 `cat` 命令中间会执行 `open`、`read`、`write` 等调用，发现 `open` 返回的 fd 是 3。一个进程默认会有 3 个 fd，标准输入、标准输出和错误输出，这 3 种 IO 占用了 0 / 1 / 2 这 3 个 fd，所以第一个用户主动打开的 fd 是 3。

### 随机读写

上面的读写是顺序读写，即从文件的开始读写到末尾，但是很多场景是从文件制定 offset 处开始读写，比如数据库系统。

每个打开的文件结构 `struct file` 中有个参数 `off`，表示当前读写到哪个位置了，而 `lseek` 就是将读写的 offset 移动到指定位置的命令。同样，第一个参数需要传入 fd。第 2 个参数是 offset，第 3 个参数是说，第二个参数 offset 怎么用：

-   SEEK_SET：就是移动到 offset 对应的位置
-   SEEK_CUR：当前 offset 加上传入的 offset
-   SEEK_END：文件大小加上 offset

`lseek` 并没有执行真正的磁盘寻址，只是将内存中 `file` 结构中的参数变化了一下，真正的寻址是将读写指定发给磁盘的时候才执行的。

### 共享 file table

当调用 `fork()` 命令创建子进程的时候，子进程和父进程共享 fd，这时系统会记录 fd 的引用数，只有 fd 引用数为 0 时才会执行关闭清理操作。

`dup()` 系统调用也可以共享 fd，Unix shell 使用 `dup` 命令和管道实现输入输出重定向。

### fsync

当调用 `write` 命令写入数据的时候，操作系统并不是直接刷入磁盘的，为了保证性能，操作系统会缓存一些数据，最后一起刷入磁盘，避免了写盘时的频繁寻道。`fsync` 命令就是直接刷盘，保证数据已经写入磁盘，避免未刷盘的数据在系统突然宕机时丢失。

然而，`fsync` 并不是百分百保证数据就刷入的磁盘，磁盘驱动器本省可能也有缓存后批量提交的机制，`fsync` 只是保证操作系统发出了刷盘的指令并把数据提交给了磁盘驱动，仍然有丢失数据的风险，要看底层磁盘驱动的机制是怎么样的。

### 重命名

`rename` 是个原子操作，借助原子性可以实现一些机制，比如编辑器修改文件时，不直接修改文件，而是先创建一个其他名字的文件，当用户执行保存操作后，将临时文件”转正“，重命名为对应的文件，因为重命名是原子性的，可以保证要么成功要么失败。

### 获取文件信息

`stat` 或者 `fstat` 命令可以获取文件的元信息，比如文件大小、inode、权限信息、读写时间戳等。

### 删除文件

删除文件的指令不是 rm / remove / delete，而是 `unlink`。文件真正的信息通过 inode 查找，一个 inode 可能对应多个文件（link 操作），因此 inode 也有引用计数，只有当 inode 的引用计数为 0 后，才执行真正的删除操作，因此删除文件只是将一个文件和 inode 的关系断开，实际真正的数据是否被删除，还要看 inode 是否真正释放了。

### 创建文件夹

通过 `mkdir` 命令创建文件夹。

### 读取文件夹

`opendir` / `readdir` / `closedir` 命令用来操作文件夹。

### 删除文件夹

`rmdir` 用来删除文件夹，一个文件夹下面可能会有很多文件，直接删除文件夹也会删除它包含的文件，是个危险的操作，为了保证安全，默认被删除的文件夹需要是空文件夹。

### 硬链和软链

通过 `ln` 命令创建一个硬链接，原始文件和硬链接文件共享 inode，删除文件时只是解除了文件和 inode 的链接关系，这就是上面的删除文件操作为什么是 `unlink` 而不是 `delete`。

`ln -s` 命令创建一个软链接，只是新建一个软链文件，这个文件指向了原始文件，如果原始文件被删除，那么软链也无法访问了。

为什么有了硬链还要有软链？原因是，inode 是文件系统级别私有的，一个操作系统可以挂在多个文件系统，那么硬链接就无法跨文件系统，而软链接只是在操作系统管理的文件上设置了一个”指针“，自然不受到 inode 的限制。

### 权限位和访问控制列表

文件系统是操作系统内共享的，如果保证安全，需要对文件设置权限。

权限位控制的权限有 3 种，读、写、执行，用 3 个 bit 表示，1-1-1 则表示可读可写可执行，表达为二进制则为 7，`chmod` 命令可以直接通过传入二进制数据来设置权限。由于操作系统对用户进行隔离，文件的权限又分为 3 种用户级别的权限，即 owner / user group / other，比如 `-rwxrw-r--` 则表示该文件的 owner 有读写执行权限，该用户组其他用户有读写权限，其余的人只有读权限。

除了权限位，一些操作系统通过访问控制列表（ACL）来控制权限。

## 创建和挂载文件系统

通常使用 `mkfs` 来创建一个文件系统，在设备或接口上创建一个指定格式的空文件系统，然后通过 `mount` 命令挂载到操作系统的某个目录上。比如新建的文件系统的根目录有一个文件 `/test.txt`，将这个文件系统挂载到 `/home/user1/` 上，那么访问这个文件的时候，通过路径 `/home/user1/test.txt` 访问。

操作系统的文件树上可以挂载不同的文件系统。

# 文件系统实现

使用一个非常简单的文件系统来深入了解下文件系统到底是如何实现的。

要实现一个文件系统，需要有两方面的考虑：

1. 文件系统的数据结构是怎么样的，文件系统的数据结构不像进程那样，在内存中，而是在持久化的磁盘中，应该如何高效组织数据结构
2. 文件系统对外的接口应该如何使用这些数据结构

首先，需要将整个磁盘分为多个块（**block**），block 大小一般是固定的 4K。之后，对这些块分区域，不同的区域作用不同：

- super block：包含了整个磁盘上文件系统的元信息，magic number / inode 个数和区域 / data block 个数和区域等
- inode bitmap: 用来标识 inode 分配情况的 bitmap
- data block bitmap: 用来标识 data block 分配情况的 bitmap
- inode region: 存放 inode 的区域
- data region：存放真正数据的区域

## inode

inode 可以说是文件系统中最重要的数据结构了，几乎所有的文件系统都有这个结构。

ext2 文件系统的 inode 包含如下信息：

- i-number: inode 编号，只要知道编号，就能计算出 inode 的位置，获取到 inode 信息
- mode：文件是否可读可写可执行
- uid：inode 的 owner
- gid：所属的 user group
- size：文件大小
- time / ctime / mtime / dtime：访问时间 / 创建时间 / 修改时间 / 删除时间
- links_count：硬链的个数，引用计数，用来判断 inode 是否可被回收
- blocks：这个文件包含多少个 block
- flags：ext2 文件系统用到的标识
- osd1：给操作系统留的
- block：文件包含的块信息，一般是指针，指向另一个地方
- generation：版本信息
- file_acl / dir_acl：acl 信息

上述信息中，最重要的是 block 信息，用来保存文件包含的数据块信息，如果文件比较大，包含成百上千个 block，那么 inode 本身是放不下的，因此需要另一种结构来保存这些信息：多级索引。和虚拟内存表映射表一样，一个指针指向另一个索引。

inode 内一般支持固定个数的 block 直接指针，如果不够用，那么就要用到间接指针，这个间接指针指向了一个多级索引，多级索引放在 data block region 内。经过实验证明，大部分文件都是小文件，这样的设计是非常有效的。

多级索引的目的是支持大文件，但是不仅仅多级索引这一种方式，还可以使用 offset-length 这种方式，分配连续的 block，指定文件从哪个块开始，长度是多少，比如早起 Windows 系统就使用了这种实现，问题是产生碎片，所以 Windows 提供了磁盘整理工具。

当然，这只是一种数据结构，只要能够实现需求的设计都是可以的。

## 文件夹组织

文件夹结构的核心作用是里边存放子文件和文件夹信息，一个包含了 `<name, i-number>` 的列表。

文件系统将文件夹看为特殊的文件，文件夹的 inode 信息和文件基本一致，不过 `block` 指针指向的 block 中不是文件数据，而是文件夹存放自己包含的信息的数据，可能是一个 list，也可能是 b-tree（方便根据文件名查找 inode）。

## 空闲空间管理

新建文件、append 文件、删除文件时都需要分配或回收空闲的空间，如上文提到的 `inode bitmap` / `data bitmap` 就用来查找哪里有空闲空间，除此之外，文件系统还要有分配策略，避免频繁 IO，以及分配的 block 距离不要太远，避免顺序读写时磁头频繁寻道。

## 分析访问流程

书中分析了一个文件的读写流程。

给定一个路径，如何找到这个文件路径的 inode？根据 '/' 分割各级文件夹，从 root 文件夹 / 找起。那么根文件夹的 inode 是啥？一般是第一个 inode。然后遍历每一级路径，找到下一级目录的 inode，直到找到该文件，最终找到 inode 以后，操作系统分配一个 fd，和该 inode 绑定。

读文件需要判断权限、修改文件的访问时间等，写文件的时候多了一些分配空间的操作，如果是新文件需要读 inode bitmap，分配 inode、data block 等，涉及到多次 IO。

## 缓存和缓冲区

为了提升性能，文件系统会有一个缓存区域，用来存放热点 block。这个缓存是固定大小的，在系统启动时就分配了，一般 Unix 系统分配总内存的 10%。但是固定大小的缓存可能存在浪费的情况，因此会和虚拟内存映射物理内存的缓存一起使用，这块固定大小的缓存被虚拟内存系统使用的多了，文件系统使用就使用少点。

除了缓存外，文件系统有个缓冲区，写入的数据不是立马写入磁盘的，而是先放到缓冲区中，有如下好处：

1. 如果写了的数据立马读，那么直接读缓冲区就行了，提升了效率。
2. 缓冲区的多个写请求一起处理，只需要修改一次 inode bitmap / data bitmap 就行
3. 批量写可以通过调度手段，减少磁盘寻道，将随机写转化为顺序写
4. 刚写入的数据就删除，直接在缓冲区操作就不需要触发磁盘 IO 了

缺点就是如果系统掉电或者崩溃，缓冲区的数据会丢失。

# FFS: Fast File System

当 Unix 系统开发时，第一版的文件系统 "Old Unix File System" 非常简单，但是性能很差，甚至随着不断写入数据，最终的写入速度只能达到最高速的 2%。

主要的问题是，它把硬盘当做了允许随机读写的内存，而没有好好考虑数据的存放方式，比如 inode 距离数据块很远，同一个文件的数据块可能也距离很远，导致读文件时大部分时间都花在寻址上了（读完 inode 读数据块需要寻道，读每个 block 可能也需要磁盘寻道）。除此之外，每个 block 的大小也很小，只有 512 byte，导致碎片较多。

FFS 设计时就考虑了硬盘是个磁盘，从而针对磁盘的特性，相比旧的文件系统极大提升了性能。

## 柱面组

FFS 做的第一步就是将磁盘分为了很多柱面组：

-   柱面：距离磁盘中心距离相同的磁道成为柱面，比如磁盘每个磁面的最外圈磁道组成一个柱面
-   柱面组：相邻的几个柱面组成一个柱面组

但是现代磁盘通常对上层隐藏了它的物理结构，只暴露了连续的地址空间（定长的 block），但是将连续的一段地址空间分组，称为 **block group**，物理层次上不一定对应着柱面组，但是也是距离很近的。不管叫做柱面组还是 block group，FFS 使用这种机制提升了性能。

FFS 将文件系统需要的元数据放置在了每个组中，除了 super block 是每个组都一样的以外（super block 比较重要，空间也不大，还能作为故障备份），其他 inode-bitmap / block-bitmap 都是每组私有的。

## 文件创建策略

FFS 分组之后，空间分配策略是将相关的东西放在同一个组内。

文件夹的放置策略是，找到一个分配文件夹最少且空闲 inode 最多的组，既能分散文件夹又能有足够的空间分配 inode 给这个文件夹的子文件。

文件的放置策略是：

-   将文件的 data block 和 inode 分配在同一个组内
-   同一个文件夹内的子文件分配在同一个组内

## 大文件处理

大文件可能占据一整个组，因此对于大文件有额外的处理逻辑。

FFS 将文件分割为多个 chunk，每个 chunk 包含多个 block，当在 inode 所在的组内放置了一个 chunk 之后，下次分配 chunk 就在另一个组内，再下一个 chunk 又放置到另一个其他的组内。chunk 的 size 决定了性能，又是一个调参的配置。

## 其他问题

大多数文件都是 2 KB 左右的文件，并不能占满一个 4 KB 的 block，为了防止内部碎片问题，FFS 定义了 **sub-block**，每个 sub-block 大小为 512 byte，当创建小于 4 KB 的文件时，分配 sub-block，如果文件后面又写入了数据，超过 4 KB，就将 sub-block 拷贝到一个普通的 block 中。FFS 通过修改写入方式，buffer 写入数据，减小了 "写入 sub-block 然后拷贝到 block" 的频率。

FFS 还是最先支持长文件名的文件系统之一，而不是传统的定长文件名。另外，它还引入了软链，以及原子性的 rename 操作。
