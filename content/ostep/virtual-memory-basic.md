---
title: "内存虚拟化之基础知识"
date: 2021-06-23T20:14:15+08:00
draft: false

categories:
- 读书笔记
tags:
- ostep
- 操作系统
---

# 内存虚拟化 - 基础知识



## 地址空间

操作系统为虚拟内存提供的抽象叫做地址空间(Address Space)，是运行中的进程能够看到的内存空间。进程申请内存主要用作 3 种数据的存储：代码、堆、栈。每个进程看到的地址空间都是一样的，给进程一种自己拥有所有内存的假象，而在真正的物理内存上，实现了进程隔离，保证了内存操作的安全性。

## 目标

内存虚拟化的目标：

-   透明
-   高效
-   保护：进程之间不能互相访问对方的内存空间

## 内存操作 API

一个进程会显示申请两种类型的内存，栈和堆。栈内存由编译器隐式帮程序员申请了，并且在生命周期结束后隐式释放，如果要将该内存在生命周期之外使用，则要分配堆内存，内存管理主要关注堆内存。

### malloc()

`void *malloc(size_t size)` 申请大小为 size 的内存空间，返回指向这块内存空间的指针，一般使用类型转换转化为目标类型。size 一般使用 `sizeof()` 操作获取，因为在不同的平台上大小可能不一样，编译器会解析 `sizeof()` 的结果，而不是在运行时才解析。

### free()

释放内存，把 `malloc` 返回的指针传进去就行，内存分配器会知道释放多少内存的，不需要显示传进去。

### 使用注意事项

-   未分配内存：一些函数的指针参数是非空指针，比如 `strcpy`
-   未分配足够的内存：还是 `strcpy`，报错与否是不确定的
-   未初始化申请的内存：里边的内容是不确定的
-   未释放申请的内存：导致内存泄漏
-   提前释放了还在使用的内存：野指针 / 悬浮指针
-   重复释放内存：不可预知的后果，大部分是崩溃
-   错误调用 `free()`: 释放了未知的内存

### 系统调用

`malloc()` 和 `free()` 并不是系统调用，而是内存分配库提供的功能，这些库的底层依赖了系统调用 `brk` 和 `sbrk`，程序员不应该直接调用这些方法，除非你很清楚你在做什么，另外还可以通过 `mmap` 来分配内存，这是个系统调用。

内存分配库还提供一些其他调用，比如 `calloc()` 分配全是 0 的内存，`realloc()` 传入一个内存指针，返回一个更大的但是已经将旧内存 copy 过去的新内存地址。

## 地址转换

内存的虚拟化和 CPU 的虚拟化追求的目标一致：效率和控制。

操作系统借用硬件实现高效的地址转化，操作系统本身只管理内存分配，它需要知道哪些内存分配了哪些没分配。

和任务调度一样，我们先假设几个条件，然后逐步放松这个条件，最终实现一个实际的 VM 系统：

1.  每个进程的地址空间都是连续的
2.  进程的地址空间都不大，小于实际物理内存
3.  每个进程地址空间一样大

例子这里略过，问题是：对进程来说，它的地址空间是从 0 开始，但是实际物理内存中，该进程并不从 0 开始，怎么把寻址透明化，给进程一个假象它就是从 0 开始使用的？

### 动态重定位 Dynamic Relocation

在每个 CPU 中有两个硬件的寄存器：base 和 bound，分别用来记录进程地址空间的起始地址和该进程地址空间的总大小，比如某个进程的地址空间是 16KB，实际的物理地址在 32KB 到 48KB 之间，那么 base 就是 32KB，bound 是 16KB。进程请求访问自己的第 2KB，实际访问的物理地址是 base + target_position = 34 KB。bound 能够保证进程访问的地址空间不超过自己应该访问的区域。

这种在 CPU 里的寻址硬件成为 MMU(Memory Management Unit)，随着使用更复杂的寻址机制，MMU 的电路也更复杂。

为了支持这种硬件层面的地址转化，需要一些额外的硬件支持：

-   地址转化并检查是否越界
-   支持特权模式，只有在内核模式才能修改 base / bound
-   预期外的修改应该能抛出异常并处理

在硬件支持之上，操作系统负责一系列的操作：

1. 分配内存，操作系统需要知道哪里有空闲的内存
2. 进程退出时回收内存
3. 上下文切换时保存进程的 vm 信息，比如上文提到的 base 和 bound，而当进程重新调度的时候重新设置 vm 信息
4. 异常处理，访问越界的内存时应该抛出异常，由系统启动时注册的异常处理器进行处理

Dynamic Relocation 技术有它的局限性，它太过简单了，限制也太多了，由于分配的内存进程不一定用到，有内部碎片浪费的问题。

## 内存分段

base-and-bound 机制的问题是，虚拟内存申请了多大，实际的物理内存就占用了多大，当进程的地址空间越大，浪费也就越严重。

1960 年代提出的分段机制，将地址空间分为多个特定大小的 segment，每个 segment 都有一个 base / bound 对，来表示段地址空间。

分段也有单独的寄存器支持，叫做段寄存器。通常一个程序有 3 个分段：代码段、内存段、栈段，段寄存器如果知道这是一个什么类型的段？一种常见方式是使用虚拟地址的前 2 个 bit 做标识，比如 00 是代码段，该地址除去前 2 个 bit 的数字为段内的 offset，这样就知道去哪个段的多长的位置取数据了。有些系统也会将代码段和内存段合二为一，这样虚拟地址只需要用 1 bit 就能区分不同的段了。还有一种隐式的方式，通过判断是谁发送的寻址请求，来判断去哪个段取信息，比如程序计数器取得是代码段，基于栈的请求地址一定在栈段，剩余的在堆段。

上面忽略了一个问题，堆和栈的寻址方向是相反的，从地址空间两边往中间增长，那么在寻址时需要判断应该往哪个方向寻址，可以新增加一个标识位，1 表示往高地址寻址，0 表示往低地址寻址。

### 共享内存支持

在分段的基础上可以实现共享内存，以节省内存，需要一个额外的支持，保护位，用来标识这个段的权限，比如一些 `.so` 库是可以读并且执行的，但是不能写，而进程自己的堆和栈是可读可写的。有了保护位，硬件就又要做些支持了，需要判断是否可操作该地址。

### 段的粗细粒度

上面说的都是进程只有 3 个段，这个粒度是比较粗的粒度，还可以支持更细的粒度（后面的 page），那么一个进程就要包含更多的段，需要硬件更多的支持，操作系统还要有段表，知道哪个段在用哪个没用。

### 操作系统的责任

到现在已经大致知道内存段的原理了，内存分段也带来了一些问题：

- 上下文切换时操作系统应该保存停止进程的段信息，写入调度进程的段信息
- 段增长时操作系统的交互，应该扩增段的大小，当前段前后没有空间时要找到可用的足够大的物理内存，然后把数据迁移过去，如果内存不够也应该拒绝请求
- 最重要的问题是管理空闲的物理内存，当新的地址空间创建的时候，操作系统需要找到物理内存分配给地址空间使用，但是段地址不是固定大小的，也不是连续的，会导致产生很多不连续的小的内存碎片，导致很难分配或者让已有的段扩容，这个问题成为外部碎片。解决办法是找到更大的空闲内存，把之前的给移过去，但是移动内存是消耗很大的。当然也可以整理碎片，但是也是消耗巨大的。更简单的做法是维护一个空闲内存列表，尽量分配小内存，还有其他各种算法，但是都无法完全消除碎片，只是尽量减少碎片。

## 空闲空间管理

如果按照固定大小管理空间（比如分页），只需要维护一个 page list 就够了，但是如果要管理的是不固定的大小，问题就困难了很多。

这里主要关注非定长的空间，更倾向于用户使用层面的内存分配库，比如提供 `malloc()` 和 `free()` 的库。

### 假设

内存分配库管理的是堆内存，空闲空间管理的通用数据结构是空闲列表，列表中包含了所有空闲的内存块，重要的不是实现一个列表，而是跟踪空闲空间的数据结构。

进一步假设更关注的是外部碎片。如果分配了内存，但是进程没有完全使用，那么这是进程自身的浪费，是进程内部的碎片，而分配器剩余的无法分配的碎片称为外部碎片。这两种碎片外部碎片更有趣，所以更关注的是它。

还假设只要分配出去的内存就不会再变化，不做 compaction，直到进程主动释放。

最后，假设内存分配器管理的是一块固定大小的内存，不会再扩增或缩小。

### 基础机制

首先讨论一些基本的机制，在各种内存分配器中都很常用的技术。

#### 分割和合并

- 分割：在空闲列表中，当请求一个很小的空间时，分割一个已有的空闲空间，返回给用户指定的空间，剩下的空间仍然在列表中
- 合并：当返还空间时，看下返还空间挨着的是不是空闲空间，是的话合并

#### 跟踪已分配的区域的大小

用户调用 `free()` 时没有传入 size，需要内存分配器能够知道返还了多少空间。实现机制是在分配内存空间时不是分配指定的大小，而是在分配的空间之前加入了 **header**，包含 `size` 和 `magic_number`。比如分配 20 byte 的内存，实际分配了 28 byte，前 4 个 byte 用来保存 size，中间 4 个 byte 是 magic_nuber，最后的 20 byte 才是分配给用户的内存，返回的指针是 8 而不是 0。另外，分配内存的时候从空闲列表中寻找 28 byte 的空闲空间而不是 20 byte。

#### 内嵌的空闲列表

内存分配器也需要内存来保存空闲列表，回到了先有鸡还是先有蛋的问题，它应该怎么申请内存？

空闲列表的数据结构为链表，链表结构为：

```C
typedef struct __node_t {
  int							size;  // 当前块的大小
  struct __node_t *next; // 下一个块的地址
}
```

书上比较详细讲了内存分配并且释放之后的图，用一句话概括：内存是一个一个的块，已分配的块结构为 size / magic_number / data，空闲块的结构为 size / next_free_space_addr / free_space，可以看成是一个抽象内存块的两种不同实现。

#### 堆扩容

向操作系统申请更多的内存，然后管理这些内存。

### 基础策略

- Best Fit：在能找到的足够大的空闲块中返回一个最小的，缺点是比较慢
- Worst Fit: 和 Best Fit 相反，找到最大的，然后分割，缺点是产生碎片
- First Fit: 第一个合适的，缺点是空闲列表的前边都是小碎片，一种优化措施是列表按照地址排序，这样返还内存的时候就能合并碎片
- Next Fit: 额外维护一个指针，指向上次找到的空闲块，下次从这个块开始搜索，这样碎片就不总是在头部，而是均匀分布

### 一些其他实现

#### 隔离列表

如果程序总是申请某个或某些固定大小的空间，那么就为这些请求单独搞个列表出来，其余的普通请求走普通分配器的逻辑。那么应该给这个特殊的分配器分配多大的内存？Solaris kernel 使用的 slab allocator 以一种很好的方式实现了，在内核启动的时候，就预分配一些内核常用的空间，比如锁、inode 对象。如果这些快用尽了，就向通用分配器再申请一些内存，相反，如果使用率比较低，通用分配器也可以从这些特定分配器中拿走一些内存。上面这种方式通过提前申请内存并初始化，减少了频繁申请内存并初始化的开销。

#### 伙伴分配

伙伴分配的目的是简化释放内存后合并碎片的逻辑。分配器总是分配 2 的幂次方的内存，比如 1KB、2KB、4KB，而不会直接分配 3KB 的内存，即使用户申请的是 3KB，所以会有内部碎片的问题。当用户申请内存的时候，会将空闲内存递归地一分为二。当用户返还内存的时候，跟它相邻的内存（伙伴）大小是一样的，而且很容易计算它的伙伴地址，因为它俩的地址在二进制只有一位不同。

#### 其他实现

上面提到的分配器缺点都是扩展性较差，空闲块太多时性能很差，所以现代的分配器都使用了比较复杂高效的数据结构，比如二叉搜索树等。另外，为了考虑多线程环境的使用，还会针对性优化。

